#!/usr/bin/env bash
set -Eeuo pipefail

# Keeps a Cloudflare quick tunnel alive and syncs OLLAMA_BASE_URL to Render.
# Usage:
#   cp .env.render-sync.example .env.render-sync
#   cp .env.render-values.example .env.render-values
#   ./scripts/render_quick_tunnel_sync.sh

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

CONFIG_FILE="${1:-$PROJECT_ROOT/.env.render-sync}"

if [[ ! -f "$CONFIG_FILE" ]]; then
  echo "ERROR: config file not found: $CONFIG_FILE" >&2
  echo "Create it from .env.render-sync.example" >&2
  exit 1
fi

set -a
# shellcheck disable=SC1090
source "$CONFIG_FILE"
set +a

RENDER_API_BASE="${RENDER_API_BASE:-https://api.render.com/v1}"
SYNC_STATIC_ENV_FILE="${SYNC_STATIC_ENV_FILE:-$PROJECT_ROOT/.env.render-values}"
RUNTIME_ENV_FILE="${RUNTIME_ENV_FILE:-$PROJECT_ROOT/.env.tunnel-runtime}"
RENDER_TRIGGER_DEPLOY="${RENDER_TRIGGER_DEPLOY:-true}"
RESTART_DELAY_SECONDS="${RESTART_DELAY_SECONDS:-3}"
TUNNEL_TARGET="${TUNNEL_TARGET:-http://localhost:11434}"
TUNNEL_HOST_HEADER="${TUNNEL_HOST_HEADER:-localhost:11434}"
RENDER_SERVICE_URL="${RENDER_SERVICE_URL:-}"
RENDER_SERVICE_NAME="${RENDER_SERVICE_NAME:-}"

LAST_OLLAMA_BASE_URL=""

resolve_path() {
  local path="$1"
  if [[ "$path" = /* ]]; then
    printf '%s' "$path"
  else
    printf '%s' "$PROJECT_ROOT/$path"
  fi
}

SYNC_STATIC_ENV_FILE="$(resolve_path "$SYNC_STATIC_ENV_FILE")"
RUNTIME_ENV_FILE="$(resolve_path "$RUNTIME_ENV_FILE")"

log() {
  printf '[%s] %s\n' "$(date +"%Y-%m-%d %H:%M:%S")" "$*"
}

require_bin() {
  if ! command -v "$1" >/dev/null 2>&1; then
    log "ERROR: required binary not found: $1"
    exit 1
  fi
}

json_escape() {
  local value="${1-}"
  value="${value//\\/\\\\}"
  value="${value//\"/\\\"}"
  value="${value//$'\n'/\\n}"
  value="${value//$'\r'/}"
  printf '%s' "$value"
}

render_api_call() {
  local method="$1"
  local path="$2"
  local body="${3:-}"
  local response_file
  local http_code

  response_file="$(mktemp)"
  if [[ -n "$body" ]]; then
    http_code="$(
      curl -sS \
        -X "$method" \
        "${RENDER_API_BASE}${path}" \
        -H "Authorization: Bearer ${RENDER_API_KEY}" \
        -H "Content-Type: application/json" \
        --data "$body" \
        -o "$response_file" \
        -w "%{http_code}"
    )"
  else
    http_code="$(
      curl -sS \
        -X "$method" \
        "${RENDER_API_BASE}${path}" \
        -H "Authorization: Bearer ${RENDER_API_KEY}" \
        -H "Content-Type: application/json" \
        -o "$response_file" \
        -w "%{http_code}"
    )"
  fi

  if (( http_code < 200 || http_code >= 300 )); then
    log "Render API error (${method} ${path}) status=${http_code}"
    cat "$response_file" >&2
    rm -f "$response_file"
    return 1
  fi

  cat "$response_file"
  rm -f "$response_file"
}

upsert_render_env_var() {
  local key="$1"
  local value="$2"
  local escaped
  escaped="$(json_escape "$value")"
  render_api_call "PUT" "/services/${RENDER_SERVICE_ID}/env-vars/${key}" "{\"value\":\"${escaped}\"}" >/dev/null
  log "Render env updated: ${key}"
}

is_placeholder() {
  local value="${1:-}"
  case "$value" in
    ""|"your_render_api_key"|"<render_api_key>"|"your_render_service_id"|"<render_service_id>")
      return 0
      ;;
    *)
      return 1
      ;;
  esac
}

trigger_render_deploy() {
  local deploy_mode="${RENDER_TRIGGER_DEPLOY,,}"
  if [[ "$deploy_mode" != "true" ]]; then
    return 0
  fi
  render_api_call "POST" "/services/${RENDER_SERVICE_ID}/deploys" "{}" >/dev/null
  log "Render deploy triggered"
}

trim() {
  local value="$1"
  value="${value#"${value%%[![:space:]]*}"}"
  value="${value%"${value##*[![:space:]]}"}"
  printf '%s' "$value"
}

sync_static_envs() {
  if [[ ! -f "$SYNC_STATIC_ENV_FILE" ]]; then
    log "Static env file not found (skip): $SYNC_STATIC_ENV_FILE"
    return 0
  fi

  log "Syncing static Render envs from: $SYNC_STATIC_ENV_FILE"
  while IFS= read -r raw_line || [[ -n "$raw_line" ]]; do
    local line
    local key
    local value
    line="${raw_line%%#*}"
    line="$(trim "$line")"
    [[ -z "$line" ]] && continue
    [[ "$line" != *=* ]] && continue

    key="$(trim "${line%%=*}")"
    value="${line#*=}"
    value="${value%$'\r'}"

    if [[ ! "$key" =~ ^[A-Za-z_][A-Za-z0-9_]*$ ]]; then
      log "Skipping invalid env key: $key"
      continue
    fi

    if [[ "$value" == \"*\" && "$value" == *\" ]]; then
      value="${value:1:-1}"
    elif [[ "$value" == \'*\' && "$value" == *\' ]]; then
      value="${value:1:-1}"
    fi

    upsert_render_env_var "$key" "$value"
  done < "$SYNC_STATIC_ENV_FILE"

  trigger_render_deploy
}

extract_quick_tunnel_url() {
  local line="$1"
  if [[ "$line" =~ (https://[A-Za-z0-9-]+\.trycloudflare\.com) ]]; then
    printf '%s' "${BASH_REMATCH[1]}"
    return 0
  fi
  return 1
}

write_runtime_env() {
  local ollama_base_url="$1"
  cat > "$RUNTIME_ENV_FILE" <<EOF
# Auto-generated by scripts/render_quick_tunnel_sync.sh
# Updated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
OLLAMA_BASE_URL=${ollama_base_url}
EOF
  log "Local runtime env updated: $RUNTIME_ENV_FILE"
}

sync_dynamic_ollama_url() {
  local tunnel_url="$1"
  local ollama_base_url="${tunnel_url%/}/v1"

  if [[ "$ollama_base_url" == "$LAST_OLLAMA_BASE_URL" ]]; then
    return 0
  fi

  LAST_OLLAMA_BASE_URL="$ollama_base_url"
  write_runtime_env "$ollama_base_url"
  upsert_render_env_var "OLLAMA_BASE_URL" "$ollama_base_url"
  trigger_render_deploy
}

run_tunnel_once() {
  local line
  local tunnel_url
  log "Starting quick tunnel -> target=${TUNNEL_TARGET}"
  while IFS= read -r line; do
    printf '[cloudflared] %s\n' "$line"
    if tunnel_url="$(extract_quick_tunnel_url "$line")"; then
      log "Detected quick tunnel URL: ${tunnel_url}"
      sync_dynamic_ollama_url "$tunnel_url"
    fi
  done < <(
    cloudflared tunnel \
      --url "$TUNNEL_TARGET" \
      --http-host-header="$TUNNEL_HOST_HEADER" 2>&1
  )
}

cleanup() {
  log "Stopping tunnel sync"
  exit 0
}

if [[ -z "${RENDER_API_KEY:-}" ]]; then
  echo "ERROR: RENDER_API_KEY is required in $CONFIG_FILE" >&2
  exit 1
fi

if is_placeholder "${RENDER_API_KEY}"; then
  echo "ERROR: RENDER_API_KEY is still a placeholder in $CONFIG_FILE" >&2
  exit 1
fi

discover_service_id() {
  local payload
  local discovered

  if [[ -n "${RENDER_SERVICE_ID:-}" ]] && ! is_placeholder "${RENDER_SERVICE_ID}"; then
    return 0
  fi

  if [[ -z "$RENDER_SERVICE_URL" && -z "$RENDER_SERVICE_NAME" ]]; then
    echo "ERROR: set RENDER_SERVICE_ID, or RENDER_SERVICE_URL, or RENDER_SERVICE_NAME in $CONFIG_FILE" >&2
    exit 1
  fi

  log "Resolving Render service id from API..."
  payload="$(render_api_call "GET" "/services")"
  discovered="$(
    printf '%s' "$payload" | TARGET_URL="$RENDER_SERVICE_URL" TARGET_NAME="$RENDER_SERVICE_NAME" \
      python -c '
import json
import os
import sys
from urllib.parse import urlparse

target_url = (os.environ.get("TARGET_URL") or "").strip()
target_name = (os.environ.get("TARGET_NAME") or "").strip().lower()
target_host = ""
if target_url:
    try:
        target_host = (urlparse(target_url).netloc or "").lower()
    except Exception:
        target_host = ""

def extract_services(blob):
    if isinstance(blob, list):
        return blob
    if not isinstance(blob, dict):
        return []
    for key in ("services", "data"):
        value = blob.get(key)
        if isinstance(value, list):
            return value
    return [blob]

def as_service(item):
    if isinstance(item, dict) and isinstance(item.get("service"), dict):
        return item["service"]
    return item if isinstance(item, dict) else {}

def service_url(svc):
    details = svc.get("serviceDetails")
    if isinstance(details, dict) and isinstance(details.get("url"), str):
        return details["url"]
    if isinstance(svc.get("url"), str):
        return svc["url"]
    return ""

def service_name(svc):
    for key in ("name", "slug"):
        value = svc.get(key)
        if isinstance(value, str):
            return value
    return ""

raw = sys.stdin.read().strip()
if not raw:
    print("")
    sys.exit(0)

try:
    parsed = json.loads(raw)
except Exception:
    print("")
    sys.exit(0)

matches = []
for item in extract_services(parsed):
    svc = as_service(item)
    sid = svc.get("id")
    if not isinstance(sid, str) or not sid:
        continue
    name = service_name(svc)
    url = service_url(svc)
    host = ""
    if url:
        try:
            host = (urlparse(url).netloc or "").lower()
        except Exception:
            host = ""
    score = 0
    if target_host and host == target_host:
        score = 3
    elif target_name and name.lower() == target_name:
        score = 2
    elif target_name and target_name in name.lower():
        score = 1
    if score > 0:
        matches.append((score, sid))

if len(matches) == 1:
    print(matches[0][1])
    sys.exit(0)

if len(matches) > 1:
    matches.sort(key=lambda x: x[0], reverse=True)
    top_score = matches[0][0]
    top = [sid for score, sid in matches if score == top_score]
    if len(top) == 1:
        print(top[0])
        sys.exit(0)

# Last fallback: if there is only one service in account, use it.
services = [as_service(item) for item in extract_services(parsed) if isinstance(as_service(item).get("id"), str)]
if len(services) == 1:
    print(services[0]["id"])
    sys.exit(0)

print("")
'
  )"

  if [[ -z "$discovered" ]]; then
    echo "ERROR: could not resolve RENDER_SERVICE_ID automatically." >&2
    echo "Set RENDER_SERVICE_ID manually in $CONFIG_FILE." >&2
    exit 1
  fi

  RENDER_SERVICE_ID="$discovered"
  export RENDER_SERVICE_ID
  log "Resolved Render service id: $RENDER_SERVICE_ID"
}

discover_service_id

if is_placeholder "${RENDER_SERVICE_ID:-}"; then
  echo "ERROR: RENDER_SERVICE_ID is still a placeholder in $CONFIG_FILE" >&2
  exit 1
fi

require_bin "cloudflared"
require_bin "curl"
require_bin "python"

trap cleanup INT TERM

sync_static_envs

while true; do
  run_tunnel_once || true
  log "cloudflared exited. Restarting in ${RESTART_DELAY_SECONDS}s..."
  sleep "$RESTART_DELAY_SECONDS"
done
